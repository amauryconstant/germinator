stages:
  - build-ci
  - setup
  - validate
  - tag
  - distribute

# --------------------------------
# Cache configuration
# --------------------------------
.cache_config: &cache_config
  key:
    files:
      - .cache-key
  paths:
    - .cache/go-mod/
    - .go/pkg/mod/

# --------------------------------
# Pipeline rules
# --------------------------------
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
    - if: '$CI_COMMIT_TAG'

# --------------------------------
# Global variables
# --------------------------------
variables:
  GOPATH: "$CI_PROJECT_DIR/.go"
  GOMODCACHE: "$CI_PROJECT_DIR/.cache/go-mod"

# --------------------------------
# Build CI Docker Image
# --------------------------------
build-ci-image:
  stage: build-ci
  image:
    name: docker:29.1.4-cli
  services:
    - name: docker:29.1.4-dind
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - Dockerfile.ci
        - .mise/config.toml
    - when: manual
      allow_failure: true
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
    CI_REGISTRY: registry.gitlab.com
    CI_REGISTRY_IMAGE: "$CI_REGISTRY/amoconst/germinator/ci"
  before_script:
    - apk add --no-cache curl
    - echo "$CI_REGISTRY_PASSWORD" | docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin
  script:
    - |
      get_mise_version() {
        local retries=3
        local retry=0
        local version=""

        while [ $retry -lt $retries ]; do
          version=$(curl -s https://api.github.com/repos/jdx/mise/releases/latest \
            | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')

          if [ -n "$version" ]; then
            echo "$version"
            return 0
          fi

          retry=$((retry + 1))
          if [ $retry -lt $retries ]; then
            echo "Retry $retry/$retries: Failed to get mise version"
            sleep 2
          fi
        done

        echo "Failed to get mise version from GitHub API after $retries attempts"
        return 1
      }

      calculate_image_hash() {
        # Generate 12-character SHA256 hash from Dockerfile.ci and .mise/config.toml
        cat Dockerfile.ci .mise/config.toml | sha256sum | cut -c1-12
      }

      MISE_VERSION=$(get_mise_version)
      if [ $? -ne 0 ]; then
        echo "Using cached mise version if available"
        MISE_VERSION="2026.1.2"
      fi

      IMAGE_HASH=$(calculate_image_hash)
      IMAGE_TAG="${MISE_VERSION}-${IMAGE_HASH}"
      echo "Mise version: $MISE_VERSION"
      echo "Image hash: $IMAGE_HASH"
      echo "Image tag: $IMAGE_TAG"

      if docker manifest inspect "$CI_REGISTRY_IMAGE:$IMAGE_TAG" > /dev/null 2>&1; then
        echo "CI image $CI_REGISTRY_IMAGE:$IMAGE_TAG already exists, skipping build"
        exit 0
      fi

      docker build \
        -t "$CI_REGISTRY_IMAGE:latest" \
        -t "$CI_REGISTRY_IMAGE:$IMAGE_TAG" \
        -f Dockerfile.ci .
      docker push "$CI_REGISTRY_IMAGE:latest"
      docker push "$CI_REGISTRY_IMAGE:$IMAGE_TAG"

# --------------------------------
# Default job configs
# --------------------------------
default:
  image: registry.gitlab.com/amoconst/germinator/ci:latest
  cache:
    key:
      files:
        - .cache-key
    paths:
      - .cache/go-mod/
      - .go/pkg/mod/
    policy: pull-push

# --------------------------------
# Setup (dependency resolution)
# --------------------------------
setup:
  stage: setup
  resource_group: cache_updates
  cache:
    <<: *cache_config
    policy: pull-push
  before_script:
    - |
      generate_cache_key() {
        local checksum=""
        # Process files in deterministic order
        for file in .gitlab-ci.yml Dockerfile.ci .mise/config.toml go.mod go.sum; do
          if [ -f "$file" ]; then
            local file_hash=$(sha256sum "$file" | awk '{print $1}')
            checksum="${checksum}${file}:${file_hash}|"
          fi
        done
        # Write to cache key file (remove trailing pipe)
        echo "${checksum%|}" > .cache-key
      }
      generate_cache_key
  script:
    - go mod download
  artifacts:
    paths:
      - .cache/go-mod/
      - .go/pkg/mod/
      - .cache-key
    expire_in: 24 hours

lint:
  stage: validate
  needs: [setup]
  cache:
    <<: *cache_config
    policy: pull
  interruptible: true
  script:
    - golangci-lint run
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - openspec/**/*
      when: never
    - when: on_success

test:
  stage: validate
  needs: [setup]
  cache:
    <<: *cache_config
    policy: pull
  script:
    - go test ./... -v
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - openspec/**/*
      when: never
    - when: on_success
 
# --------------------------------
# Automatic Tag Creation
# --------------------------------
create-version-tag:
  stage: tag
  variables:
    GIT_STRATEGY: clone
  before_script:
    - git config user.email "$GITLAB_USER_EMAIL"
    - git config user.name "$GITLAB_USER_NAME"
    - git remote set-url origin "https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/amoconst/germinator"
  script:
    - |
      echo "ðŸ·ï¸  Determining version..."
      VERSION=$(grep 'Version = "' internal/version/version.go | sed 's/.*Version = "\(.*\)".*/\1/' | xargs)
      if [ -z "$VERSION" ]; then
        echo "ERROR: Could not extract version from internal/version/version.go"
        exit 1
      fi
      export TAG="v$VERSION"
      echo "Current version: $VERSION"
      echo "Creating tag: $TAG"
    - git fetch --tags --prune
    - |
      if git tag -l "$TAG" | grep -q "$TAG"; then
        echo "âœ… Tag $TAG already exists, skipping creation"
      else
        echo "ðŸ·ï¸  Creating new tag $TAG..."
        git tag -a "$TAG" -m "Release $TAG"
        git push origin "$TAG"
        echo "âœ… Tag $TAG created and pushed successfully"
      fi
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      changes:
        - internal/version/version.go
    - when: never

# --------------------------------
# Release with GoReleaser
# --------------------------------
release:
  stage: distribute
  needs: [lint, test]
  image:
    name: goreleaser/goreleaser
    entrypoint: [""]
  variables:
    GIT_DEPTH: 0
    GITLAB_TOKEN: "$CI_JOB_TOKEN"
  before_script:
    - |
      # Validate tag matches code version (only check that matters in CI)
      TAG_VERSION="${CI_COMMIT_TAG#v}"
      CODE_VERSION=$(grep 'Version = "' internal/version/version.go | sed 's/.*Version = "\(.*\)".*/\1/' | xargs)
      if [ "$TAG_VERSION" != "$CODE_VERSION" ]; then
        echo "ERROR: Tag version $TAG_VERSION does not match code version $CODE_VERSION"
        exit 1
      fi
  script:
    - goreleaser release --clean
  rules:
    - if: '$CI_COMMIT_TAG'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - openspec/**/*
      when: never
    - when: on_success

# --------------------------------
# Mirror to GitHub
# --------------------------------
mirror-to-github:
  stage: distribute
  needs: [create-version-tag]
  variables:
    GIT_STRATEGY: fetch
  script:
    - git remote add github "https://${GITHUB_ACCESS_TOKEN}@github.com/${GITHUB_REPO_URL}.git" || true
    - git push github "$CI_COMMIT_BRANCH" --force
    - git push github --tags --force
  interruptible: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $GITHUB_ACCESS_TOKEN && $GITHUB_REPO_URL'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - openspec/**/*
      when: never
    - when: on_success
